# OSI Model - Question Log

> [!abstract] Learning Guide
> These questions test understanding of the OSI 7-layer networking model. Check off questions as you master them.
> Questions organized by layer and difficulty level.

---

## ðŸ”Œ Layer 1 - Physical

### Basic Understanding
- [ ] What is the primary purpose of Layer 1?
- [ ] Name at least 3 types of physical media used at Layer 1
- [ ] What data format does Layer 1 transport?
- [ ] Does Layer 1 use any form of addressing? Why or why not?
- [ ] What is the difference between a hub and a repeater?

### Intermediate Questions
- [ ] Explain the difference between half-duplex and full-duplex communication
- [ ] Why are hubs considered obsolete in modern networks?
- [ ] What factors affect the maximum distance of a cable run?
- [ ] Compare twisted pair, coaxial, and fiber optic cables (3 differences each)

### Advanced/Scenario-Based
- [ ] **Scenario:** Network speeds are much slower than expected. What Layer 1 issues would you check first?
- [ ] **Scenario:** You need to connect two buildings 500 meters apart. What cable type would you choose and why?
- [ ] Explain CSMA/CD and why it's necessary in half-duplex networks

> [!question]- Why can't hubs operate in full-duplex mode?
> **Question:**
> Hubs are Layer 1 devices that have been replaced by switches. Explain why hubs cannot support full-duplex communication and what this means for network performance.
>
> **Answer:**
>
> **Technical Explanation:**
> - Hubs broadcast all incoming traffic to ALL connected ports simultaneously
> - This creates a single **collision domain** where only one device can transmit at a time
> - Full-duplex requires dedicated bandwidth where devices can send and receive simultaneously
> - Since all hub ports share the same electrical bus, simultaneous transmission causes signal collisions
>
> **Real-World Impact:**
> - Hubs force networks into half-duplex mode (one direction at a time)
> - Requires CSMA/CD (Carrier Sense Multiple Access with Collision Detection)
> - Significantly reduces effective bandwidth (50% theoretical max)
> - Modern switches provide full-duplex via microsegmentation (dedicated collision domains)
>
> **Performance Comparison:**
> ```
> Hub (Half-Duplex):
> â€¢ 100 Mbps port = 50 Mbps effective (one direction at a time)
> â€¢ All ports share bandwidth
> â€¢ Collisions reduce performance further
>
> Switch (Full-Duplex):
> â€¢ 100 Mbps port = 100 Mbps send + 100 Mbps receive
> â€¢ Each port has dedicated bandwidth
> â€¢ No collisions possible
> ```
>
> **Why This Matters:**
> - Understanding collision domains is crucial for network design
> - Switches are now standard because they eliminate this limitation
> - Some legacy industrial equipment may still use hubs

---

## ðŸ”— Layer 2 - Data Link

### Basic Understanding
- [ ] What is the purpose of Layer 2?
- [ ] What does "hop-to-hop" delivery mean?
- [ ] How many bits are in a MAC address?
- [ ] What is the format of a MAC address?
- [ ] Name 3 Layer 2 technologies or devices

### MAC Addresses
- [ ] Are MAC addresses globally unique? How is this guaranteed?
- [ ] What is the difference between the first 24 bits and last 24 bits of a MAC address?
- [ ] Compare MAC address formatting on Windows vs UNIX vs Cisco devices
- [ ] Can a MAC address be changed? What is this called?

### Intermediate Questions
- [ ] What is the difference between a switch and a bridge?
- [ ] How does a switch learn MAC addresses and build its MAC address table?
- [ ] Explain the difference between a collision domain and a broadcast domain
- [ ] What happens when a switch receives a frame for an unknown MAC address?

### Advanced/Scenario-Based
- [ ] **Scenario:** A switch has 24 ports with 8 computers connected. How many collision domains exist?
- [ ] **Scenario:** PC A (192.168.1.10) sends data to PC B on the same switch. Trace the Layer 2 process step-by-step.
- [ ] Draw a diagram showing how MAC addresses change across 3 hops while IP addresses stay constant

> [!question]- Why do we need both MAC addresses AND IP addresses?
>
> ## Question
> This is one of the most fundamental networking concepts. Explain why both Layer 2 (MAC) and Layer 3 (IP) addressing are necessary.
>
> ## Short Answer
> - **MAC addresses:** Hop-to-hop delivery (local, changes every hop)
> - **IP addresses:** End-to-end delivery (global, stays constant)
>
> ## Detailed Explanation
>
> **The Problem:**
> Data needs to travel from your PC (192.168.1.10) to a web server (172.217.14.196) across multiple networks and routers.
>
> **Why IP Addresses (Layer 3):**
> - **Hierarchical structure:** Like postal addresses (country/city/street/house)
> - **Routable:** Routers use IP addresses to make forwarding decisions
> - **End-to-end:** Source and destination IP never change during the journey
> - **Scalable:** IP prefixes allow route aggregation (one route can represent millions of hosts)
>
> **Why MAC Addresses (Layer 2):**
> - **Flat structure:** Like serial numbers (no hierarchy)
> - **Local delivery:** Switches use MAC addresses to forward frames on local networks
> - **Hop-by-hop:** MAC addresses change at every router/switch
> - **Hardware-based:** Burned into NICs, allows Layer 2 forwarding without Layer 3 processing
>
> **The Journey:**
> ```
> PC A â†’ Switch â†’ Router 1 â†’ ISP â†’ Router 2 â†’ Switch â†’ Server B
>
> Hop 1 (PC â†’ Switch):
>   SRC MAC: PC_MAC       | DST MAC: SWITCH_MAC
>   SRC IP: 192.168.1.10  | DST IP: 172.217.14.196  âœ… Constant
>
> Hop 2 (Switch â†’ Router 1):
>   SRC MAC: SWITCH_MAC   | DST MAC: ROUTER1_MAC    âš¡ Changed!
>   SRC IP: 192.168.1.10  | DST IP: 172.217.14.196  âœ… Constant
>
> Hop 3 (Router 1 â†’ ISP):
>   SRC MAC: R1_WAN_MAC   | DST MAC: ISP_MAC        âš¡ Changed!
>   SRC IP: 192.168.1.10  | DST IP: 172.217.14.196  âœ… Constant
>
> [... more hops ...]
>
> Final Hop (Switch â†’ Server):
>   SRC MAC: SWITCH_MAC   | DST MAC: SERVER_MAC     âš¡ Changed!
>   SRC IP: 192.168.1.10  | DST IP: 172.217.14.196  âœ… Constant
> ```
>
> ## Analogy
>
> **Sending a Package Across the Country:**
>
> | Aspect | IP Address | MAC Address |
> |--------|-----------|-------------|
> | Purpose | Postal address on package | Delivery truck license plate |
> | Scope | Global (end-to-end) | Local (current segment) |
> | Changes? | Never | Every delivery truck handoff |
> | Used by | Post office routing | Local delivery drivers |
>
> **The postal address (IP)** stays on the package from sender to recipient, allowing postal workers to route it across the country.
>
> **The delivery truck (MAC)** changes at each depot - NYC truck â†’ sorting facility â†’ regional truck â†’ local truck â†’ final delivery van.
>
> ## Why Not Just Use One?
>
> **If we only used MAC addresses:**
> - âŒ Routers would need tables with every MAC address in the world (billions!)
> - âŒ No hierarchical routing (can't aggregate routes)
> - âŒ No way to route across networks efficiently
>
> **If we only used IP addresses:**
> - âŒ Every device would need to process Layer 3 headers (too slow for switches)
> - âŒ Local networks would be inefficient
> - âŒ Hardware-based switching wouldn't be possible
>
> ## Key Insight
>
> **Two-layer addressing allows:**
> 1. **Efficient global routing** (IP - routers use prefixes to aggregate routes)
> 2. **Fast local switching** (MAC - switches forward in hardware without Layer 3 lookup)
> 3. **Separation of concerns** (routing vs switching are different problems)
>
> ## Related Concepts
> - [[ARP]] - Maps IP addresses to MAC addresses
> - [[Routing tables]] - Use IP addresses for forwarding decisions
> - [[Switch MAC table]] - Maps MAC addresses to physical ports

### ARP (Address Resolution Protocol)
- [ ] What problem does ARP solve?
- [ ] Describe the ARP request/reply process
- [ ] What is an ARP cache/table?
- [ ] How long do ARP entries typically last?

> [!question]- How does ARP work step-by-step?
>
> ## Question
> Explain the complete ARP process when a host needs to send data to an IP address on the same local network.
>
> ## Scenario
> PC A (192.168.1.10 / MAC: AA:AA:AA:AA:AA:AA) wants to send data to PC B (192.168.1.20 / MAC: ???)
>
> ## Step-by-Step Process
>
> **Step 1: Check ARP Cache**
> ```
> PC A thinks: "I need to send data to 192.168.1.20"
> PC A checks: "Do I have the MAC address cached?"
> Command: arp -a
> Result: Not found in cache
> ```
>
> **Step 2: Broadcast ARP Request**
> ```
> PC A broadcasts to ALL devices on local network:
>
> ARP Request Frame:
> â€¢ Source MAC: AA:AA:AA:AA:AA:AA
> â€¢ Dest MAC: FF:FF:FF:FF:FF:FF (broadcast)
> â€¢ Message: "Who has IP 192.168.1.20? Tell 192.168.1.10"
>
> All devices receive this request
> ```
>
> **Step 3: Target Responds**
> ```
> PC B recognizes its IP address and responds:
>
> ARP Reply Frame:
> â€¢ Source MAC: BB:BB:BB:BB:BB:BB
> â€¢ Dest MAC: AA:AA:AA:AA:AA:AA (unicast to PC A)
> â€¢ Message: "192.168.1.20 is at BB:BB:BB:BB:BB:BB"
>
> Only PC A receives this reply
> ```
>
> **Step 4: Cache the Mapping**
> ```
> PC A saves to ARP cache:
> 192.168.1.20 â†’ BB:BB:BB:BB:BB:BB
>
> Typical cache timeout: 2-20 minutes
> Future packets to .20 use cached MAC (no ARP needed)
> ```
>
> **Step 5: Send Original Data**
> ```
> Now PC A can send the actual data:
>
> Ethernet Frame:
> â€¢ Source MAC: AA:AA:AA:AA:AA:AA
> â€¢ Dest MAC: BB:BB:BB:BB:BB:BB âœ… Now known!
> â€¢ IP Packet inside with source/dest IPs
> ```
>
> ## Visual Diagram
> ```
>     PC A                  Switch                  PC B
> (192.168.1.10)                              (192.168.1.20)
>      |                       |                      |
>      |--ARP Request--------->|                      |
>      | (broadcast to all)    |--ARP Request-------->|
>      |                       |--ARP Request-------->| PC C
>      |                       |--ARP Request-------->| PC D
>      |                       |                      |
>      |                       |<-----ARP Reply-------|
>      |<--ARP Reply-----------|                      |
>      |                       |                      |
>      |--Data Frame---------->|--Data Frame--------->|
>      |  (unicast to B)       |  (unicast to B)      |
> ```
>
> ## What Gets Cached
> ```
> arp -a output:
>
> Interface: 192.168.1.10
> Internet Address    Physical Address      Type
> 192.168.1.1        A1-B2-C3-D4-E5-F6    dynamic
> 192.168.1.20       BB-BB-BB-BB-BB-BB    dynamic
> 192.168.1.255      FF-FF-FF-FF-FF-FF    static (broadcast)
> ```
>
> ## Important Edge Cases
>
> **Case 1: Destination on Different Network**
> - If destination IP is NOT on local subnet, PC sends to **default gateway (router)** MAC instead
> - ARP resolves gateway's IP â†’ MAC
> - Router handles forwarding to remote network
>
> **Case 2: Gratuitous ARP**
> - Device announces its own IP/MAC mapping without being asked
> - Used when IP address changes or NIC comes online
> - Updates all neighbors' ARP caches
>
> **Case 3: ARP Cache Poisoning (Security)**
> - Attacker sends fake ARP replies
> - Victims cache attacker's MAC for someone else's IP
> - Results in Man-in-the-Middle attack
>
> ## Why This Matters
> - ARP is the "glue" between Layer 2 and Layer 3
> - Without ARP, IP addresses couldn't find MAC addresses on local networks
> - Understanding ARP is crucial for troubleshooting connectivity issues
> - ARP vulnerabilities are a major security concern

---

## ðŸŒ Layer 3 - Network

### Basic Understanding
- [ ] What is the purpose of Layer 3?
- [ ] What does "end-to-end" delivery mean?
- [ ] How many bits in an IPv4 address?
- [ ] What is the format of an IPv4 address?
- [ ] Name the main Layer 3 device

### IP Addresses
- [ ] Convert 192.168.1.100 to binary
- [ ] What is the range of values for each octet in an IP address?
- [ ] Explain the difference between private and public IP addresses
- [ ] What are the three private IP address ranges (RFC 1918)?

### Intermediate Questions
- [ ] How does a router make forwarding decisions?
- [ ] What is a routing table and what information does it contain?
- [ ] Explain the difference between a switch and a router
- [ ] What is the purpose of the TTL (Time To Live) field in an IP header?
- [ ] What happens when TTL reaches 0?

### Advanced/Scenario-Based
- [ ] **Scenario:** Trace a packet from PC (192.168.1.10) to Google (8.8.8.8) through 4 routers. What changes at each hop?
- [ ] **Scenario:** Two PCs are on different subnets (192.168.1.x and 10.0.0.x). Can they communicate without a router? Why?
- [ ] Explain why IP addresses are hierarchical while MAC addresses are flat

> [!question]- What changes at each hop vs what stays constant?
>
> ## Question
> When a packet travels from source to destination across multiple networks, certain fields change at each hop while others remain constant. Identify what changes and what stays the same.
>
> ## Scenario Setup
> ```
> Source: PC A (192.168.1.10, MAC: AA:AA:AA:AA:AA:AA)
> Destination: Web Server (172.217.14.196, MAC: DD:DD:DD:DD:DD:DD)
>
> Path: PC A â†’ Switch 1 â†’ Router 1 â†’ Internet (2 hops) â†’ Router 2 â†’ Switch 2 â†’ Server
> ```
>
> ## The Answer
>
> ### âœ… Stays Constant (End-to-End)
>
> **Layer 3 - IP Headers:**
> - Source IP: `192.168.1.10`
> - Destination IP: `172.217.14.196`
> - Protocol type (TCP, UDP, ICMP, etc.)
> - Upper layer data (Layers 4-7)
>
> **Layer 4 - Transport Headers:**
> - Source Port (e.g., 54321)
> - Destination Port (e.g., 443)
> - Sequence numbers (TCP)
>
> **Layers 5-7 - Application Data:**
> - HTTP request, email content, etc.
> - Encryption (if TLS/SSL)
>
> ### âš¡ Changes at Each Hop (Hop-to-Hop)
>
> **Layer 2 - Ethernet Headers:**
> - Source MAC address
> - Destination MAC address
> - Frame Check Sequence (FCS)
>
> **Layer 3 - IP Header Fields:**
> - TTL (decrements by 1 at each router)
> - Header checksum (recalculated due to TTL change)
>
> ## Detailed Hop-by-Hop Breakdown
>
> ### Hop 1: PC A â†’ Switch 1
> ```
> Layer 2 (Ethernet Frame):
> â€¢ SRC MAC: AA:AA:AA:AA:AA:AA (PC A)
> â€¢ DST MAC: 11:11:11:11:11:11 (Switch 1)
>
> Layer 3 (IP Packet):
> â€¢ SRC IP: 192.168.1.10        âœ… Original
> â€¢ DST IP: 172.217.14.196      âœ… Original
> â€¢ TTL: 64                      (Starting value)
> ```
>
> ### Hop 2: Switch 1 â†’ Router 1 (Gateway)
> ```
> Layer 2:
> â€¢ SRC MAC: 11:11:11:11:11:11 (Switch 1)      âš¡ Changed
> â€¢ DST MAC: 22:22:22:22:22:22 (Router 1 LAN)  âš¡ Changed
>
> Layer 3:
> â€¢ SRC IP: 192.168.1.10        âœ… Unchanged
> â€¢ DST IP: 172.217.14.196      âœ… Unchanged
> â€¢ TTL: 64                      (No change yet - switch is L2 only)
> ```
>
> ### Hop 3: Router 1 â†’ ISP Router
> ```
> Layer 2:
> â€¢ SRC MAC: 33:33:33:33:33:33 (Router 1 WAN)  âš¡ Changed
> â€¢ DST MAC: 44:44:44:44:44:44 (ISP Router)    âš¡ Changed
>
> Layer 3:
> â€¢ SRC IP: 192.168.1.10        âœ… Unchanged
> â€¢ DST IP: 172.217.14.196      âœ… Unchanged
> â€¢ TTL: 63                      âš¡ Decremented by Router 1
> ```
>
> ### Hop 4: ISP Router â†’ Next Router
> ```
> Layer 2:
> â€¢ SRC MAC: 44:44:44:44:44:44 (ISP Router)    âš¡ Changed
> â€¢ DST MAC: 55:55:55:55:55:55 (Next Router)   âš¡ Changed
>
> Layer 3:
> â€¢ SRC IP: 192.168.1.10        âœ… Unchanged
> â€¢ DST IP: 172.217.14.196      âœ… Unchanged
> â€¢ TTL: 62                      âš¡ Decremented
> ```
>
> ### Final Hop: Switch 2 â†’ Server
> ```
> Layer 2:
> â€¢ SRC MAC: 77:77:77:77:77:77 (Switch 2)      âš¡ Changed
> â€¢ DST MAC: DD:DD:DD:DD:DD:DD (Server)        âš¡ Changed (finally!)
>
> Layer 3:
> â€¢ SRC IP: 192.168.1.10        âœ… Unchanged
> â€¢ DST IP: 172.217.14.196      âœ… Unchanged
> â€¢ TTL: 58                      âš¡ Decremented
> ```
>
> ## Summary Table
>
> | Field | Stays Constant? | Layer | Changes At |
> |-------|----------------|-------|------------|
> | Source IP | âœ… Yes | 3 | Never |
> | Destination IP | âœ… Yes | 3 | Never |
> | Source Port | âœ… Yes | 4 | Never |
> | Destination Port | âœ… Yes | 4 | Never |
> | Application Data | âœ… Yes | 5-7 | Never |
> | Source MAC | âŒ No | 2 | Every hop |
> | Destination MAC | âŒ No | 2 | Every hop |
> | TTL | âŒ No | 3 | Every router (L3 device) |
> | Frame Check Sequence | âŒ No | 2 | Every hop |
>
> ## Why This Design?
>
> **Layer 3 (IP) - End-to-End:**
> - Stays constant so routers know the ultimate destination
> - Allows global routing across the entire Internet
> - Hierarchical addressing enables route aggregation
>
> **Layer 2 (MAC) - Hop-to-Hop:**
> - Changes to reflect current network segment
> - Enables fast hardware-based switching
> - Only needs to know "next hop" not final destination
>
> **TTL (Time To Live):**
> - Decrements to prevent infinite routing loops
> - If packet gets stuck in a loop, TTL reaches 0 and packet is dropped
> - Typical starting values: 64 (Linux), 128 (Windows), 255 (some routers)
>
> ## Common Misconceptions
>
> âŒ **Wrong:** "MAC addresses stay the same because they're burned into the NIC"
> âœ… **Right:** "MAC addresses in the frame header change at each hop - only the NIC's own MAC is permanent"
>
> âŒ **Wrong:** "Switches change IP addresses"
> âœ… **Right:** "Switches operate at Layer 2 and don't modify IP headers - only routers process Layer 3"
>
> âŒ **Wrong:** "TTL is a time value in seconds"
> âœ… **Right:** "TTL is a hop count, not time - it decrements by 1 at each router"
>
> ## Troubleshooting Applications
>
> **Using traceroute/tracert:**
> - Sends packets with increasing TTL values (1, 2, 3, ...)
> - Each router that decrements TTL to 0 sends back an ICMP "Time Exceeded" message
> - Reveals the path packets take to reach a destination
>
> **Wireshark capture analysis:**
> - Filter by IP address to follow a specific conversation
> - Watch TTL decrease to identify number of router hops
> - Examine MAC addresses to see local network path

### Routing
- [ ] What is the default gateway?
- [ ] What is a static route vs a dynamic route?
- [ ] Name 2 routing protocols (e.g., RIP, OSPF, BGP)
- [ ] What is the purpose of a subnet mask?

---

## ðŸšš Layer 4 - Transport

### Basic Understanding
- [ ] What problem does Layer 4 solve?
- [ ] What is the range of port numbers?
- [ ] Name the two main Layer 4 protocols
- [ ] What is the difference between a client port and a server port?

### Ports
- [ ] What are "well-known ports" and what is their range?
- [ ] What are "ephemeral ports"?
- [ ] List 5 common ports (HTTP, HTTPS, SSH, DNS, FTP)
- [ ] Can multiple applications listen on the same port? Why or why not?

### TCP vs UDP
- [ ] Compare TCP and UDP (at least 4 differences)
- [ ] When would you choose TCP over UDP?
- [ ] When would you choose UDP over TCP?
- [ ] What does "connection-oriented" mean?
- [ ] What does "connectionless" mean?

> [!question]- Explain the TCP three-way handshake
>
> ## Question
> Describe the TCP three-way handshake process that establishes a connection between client and server. Include what information is exchanged and why each step is necessary.
>
> ## Quick Answer
> 1. **SYN** - Client initiates connection with sequence number
> 2. **SYN-ACK** - Server acknowledges and sends its sequence number
> 3. **ACK** - Client acknowledges server's sequence number
>
> ## Detailed Step-by-Step
>
> ### Setup
> ```
> Client: 192.168.1.10:54321 (random ephemeral port)
> Server: 172.217.14.196:443 (HTTPS)
> ```
>
> ### Step 1: SYN (Synchronize)
> ```
> Client â†’ Server
>
> TCP Header:
> â€¢ Source Port: 54321
> â€¢ Dest Port: 443
> â€¢ Sequence Number: 1000 (random initial sequence number)
> â€¢ Acknowledgment: 0
> â€¢ Flags: SYN = 1
>
> Message: "Hello server! I want to connect. My sequence number starts at 1000."
> ```
>
> **Purpose:**
> - Client announces intention to connect
> - Provides Initial Sequence Number (ISN) for tracking data bytes
> - SYN flag indicates this is a connection request
>
> ### Step 2: SYN-ACK (Synchronize-Acknowledge)
> ```
> Server â†’ Client
>
> TCP Header:
> â€¢ Source Port: 443
> â€¢ Dest Port: 54321
> â€¢ Sequence Number: 5000 (server's random ISN)
> â€¢ Acknowledgment: 1001 (client's ISN + 1)
> â€¢ Flags: SYN = 1, ACK = 1
>
> Message: "Hi client! I got your request. My sequence starts at 5000.
>           I acknowledge your sequence 1000 and expect 1001 next."
> ```
>
> **Purpose:**
> - Server acknowledges client's SYN
> - Server provides its own ISN
> - Server confirms it's ready to communicate
> - ACK number = client's ISN + 1
>
> ### Step 3: ACK (Acknowledge)
> ```
> Client â†’ Server
>
> TCP Header:
> â€¢ Source Port: 54321
> â€¢ Dest Port: 443
> â€¢ Sequence Number: 1001
> â€¢ Acknowledgment: 5001 (server's ISN + 1)
> â€¢ Flags: ACK = 1
>
> Message: "Got it! I acknowledge your sequence 5000 and expect 5001 next.
>           Connection established - sending data now..."
> ```
>
> **Purpose:**
> - Client acknowledges server's SYN-ACK
> - Connection is now fully established (ESTABLISHED state)
> - Data transmission can begin
>
> ## Visual Sequence Diagram
> ```
> Client (192.168.1.10)                    Server (172.217.14.196:443)
>       |                                            |
>       |                                            | LISTEN state
>       |                                            |
>       |------------ SYN (seq=1000) -------------->|
>       | (SYN_SENT state)                           | (SYN_RECEIVED state)
>       |                                            |
>       |<------- SYN-ACK (seq=5000, ack=1001) -----|
>       |                                            |
>       |------------ ACK (ack=5001) -------------->|
>       | (ESTABLISHED state)                        | (ESTABLISHED state)
>       |                                            |
>       |<============ Data Transfer =============>|
>       |                                            |
> ```
>
> ## Why Three Steps? Why Not Two?
>
> **Problem with 2-way handshake:**
> - Server has no confirmation that client received the SYN-ACK
> - If SYN-ACK is lost, server would wait forever
> - Old duplicate SYN packets could establish unwanted connections
>
> **Benefits of 3-way handshake:**
> - âœ… Both sides confirm they can send AND receive
> - âœ… Both sides agree on initial sequence numbers
> - âœ… Prevents old duplicate packets from creating connections
> - âœ… Establishes bidirectional communication
>
> ## Sequence Numbers Purpose
>
> ```
> After handshake, data transmission uses sequence numbers:
>
> Client sends 100 bytes:
>   SEQ = 1001, Data = 100 bytes
>
> Server acknowledges:
>   ACK = 1101 (expecting next byte at position 1101)
>
> Client sends 200 more bytes:
>   SEQ = 1101, Data = 200 bytes
>
> Server acknowledges:
>   ACK = 1301
> ```
>
> **Why sequence numbers?**
> - Track every byte of data
> - Detect missing packets (gap in sequence)
> - Detect duplicate packets (already received this sequence)
> - Reorder out-of-order packets
> - Ensure reliable delivery
>
> ## Security Implications
>
> ### SYN Flood Attack (DDoS)
> ```
> Attacker sends thousands of SYN packets with fake source IPs:
>
> Attacker â†’ Server: SYN, SYN, SYN, SYN... (flood)
> Server â†’ Fake IPs: SYN-ACK, SYN-ACK, SYN-ACK...
> Server waits for ACK that never comes (half-open connections)
>
> Result: Server's connection table fills up, denies legitimate clients
> ```
>
> **Mitigations:**
> - **SYN Cookies:** Server doesn't allocate resources until final ACK
> - **Firewall rate limiting:** Limit SYN packets per source
> - **Increase backlog queue:** Allow more half-open connections
>
> ### Connection Hijacking
> - Attacker predicts sequence numbers
> - Injects packets that appear to be part of established connection
> - Modern systems use random ISNs to prevent this
>
> ## TCP States During Handshake
>
> | Step | Client State | Server State |
> |------|-------------|--------------|
> | Initial | CLOSED | LISTEN |
> | After SYN sent | SYN_SENT | LISTEN |
> | After SYN-ACK sent | SYN_SENT | SYN_RECEIVED |
> | After ACK sent | ESTABLISHED | SYN_RECEIVED |
> | After ACK received | ESTABLISHED | ESTABLISHED |
>
> **View with:** `netstat -an` or `ss -tan` (Linux)
>
> ## Four-Way Termination (Bonus)
>
> Closing a connection is similar but requires 4 steps:
> ```
> 1. Client â†’ Server: FIN (I'm done sending)
> 2. Server â†’ Client: ACK (OK, I received that)
> 3. Server â†’ Client: FIN (I'm done too)
> 4. Client â†’ Server: ACK (OK, closing now)
> ```
>
> **Why 4 steps?**
> - TCP is full-duplex (independent send/receive channels)
> - Each direction must be closed separately
> - Server might still have data to send after receiving FIN
>
> ## Common Issues
>
> **Problem:** Connection hangs at SYN_SENT
> - Firewall blocking port
> - Server not listening on that port
> - Network connectivity issue
>
> **Problem:** Many connections in SYN_RECEIVED
> - Possible SYN flood attack
> - Network congestion dropping ACK packets
> - Check firewall logs
>
> ## Why This Matters
>
> Understanding TCP handshake is critical for:
> - **Troubleshooting:** Connection timeouts, slow connections
> - **Security:** Recognizing SYN flood attacks, firewall rules
> - **Performance:** Reducing handshake overhead (TCP Fast Open)
> - **Monitoring:** Interpreting netstat, Wireshark captures

### Advanced/Scenario-Based
- [ ] **Scenario:** You have Chrome with 3 tabs open to the same website (https://bank.com). How does Layer 4 distinguish which tab gets which data?
- [ ] **Scenario:** A gaming application is laggy despite fast internet. Would switching from TCP to UDP help? Why?
- [ ] Explain how port forwarding works on a home router

> [!question]- How do ephemeral ports work?
>
> ## Question
> When you open multiple browser tabs to the same website, how does your computer keep track of which response goes to which tab? Explain ephemeral ports.
>
> ## Scenario
> ```
> Your PC: 192.168.1.100
> You open 3 Chrome tabs to https://bank.com (172.217.14.196:443)
> All tabs connect to the same destination IP and port
> How does the OS know which response belongs to which tab?
> ```
>
> ## Answer: Ephemeral Ports
>
> **Ephemeral ports** are temporary, randomly-assigned client-side ports used to distinguish multiple connections to the same server.
>
> ### Port Ranges
> ```
> 0 - 1023:       Well-known ports (HTTP=80, HTTPS=443, SSH=22)
> 1024 - 49151:   Registered ports (application-specific)
> 49152 - 65535:  Ephemeral/Dynamic ports (client-side random)
> ```
>
> ### How It Works
> ```
> Tab 1 opens https://bank.com:
> â€¢ Client: 192.168.1.100:54321 â†’ Server: 172.217.14.196:443
>   OS assigns random port 54321
>
> Tab 2 opens https://bank.com:
> â€¢ Client: 192.168.1.100:54322 â†’ Server: 172.217.14.196:443
>   OS assigns different random port 54322
>
> Tab 3 opens https://bank.com:
> â€¢ Client: 192.168.1.100:54323 â†’ Server: 172.217.14.196:443
>   OS assigns different random port 54323
> ```
>
> ### The 5-Tuple
> Each TCP connection is uniquely identified by 5 values:
> ```
> 1. Source IP
> 2. Source Port        â† This is what differs!
> 3. Destination IP
> 4. Destination Port
> 5. Protocol (TCP/UDP)
> ```
>
> **Example:**
> ```
> Connection 1: (192.168.1.100, 54321, 172.217.14.196, 443, TCP)
> Connection 2: (192.168.1.100, 54322, 172.217.14.196, 443, TCP)
> Connection 3: (192.168.1.100, 54323, 172.217.14.196, 443, TCP)
>
> Three different connections despite same destination!
> ```
>
> ## Visual Flow
> ```
>     Your PC (192.168.1.100)              Bank Server (172.217.14.196:443)
>
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
> â”‚   Chrome Tab 1      â”‚                     â”‚              â”‚
> â”‚   Port: 54321       â”‚------ Request ----->â”‚              â”‚
> â”‚                     â”‚<----- Response â”€â”€â”€â”€â”€â”‚   Listening  â”‚
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      (to :54321)    â”‚   on Port    â”‚
>                                              â”‚     443      â”‚
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚              â”‚
> â”‚   Chrome Tab 2      â”‚                     â”‚              â”‚
> â”‚   Port: 54322       â”‚------ Request ----->â”‚              â”‚
> â”‚                     â”‚<----- Response â”€â”€â”€â”€â”€â”‚              â”‚
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      (to :54322)    â”‚              â”‚
>                                              â”‚              â”‚
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚              â”‚
> â”‚   Chrome Tab 3      â”‚                     â”‚              â”‚
> â”‚   Port: 54323       â”‚------ Request ----->â”‚              â”‚
> â”‚                     â”‚<----- Response â”€â”€â”€â”€â”€â”‚              â”‚
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      (to :54323)    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
> ```
>
> ## Server Perspective
> ```
> Server sees three separate connections:
>
> netstat -an | grep :443
> tcp  0  0  172.217.14.196:443  192.168.1.100:54321  ESTABLISHED
> tcp  0  0  172.217.14.196:443  192.168.1.100:54322  ESTABLISHED
> tcp  0  0  172.217.14.196:443  192.168.1.100:54323  ESTABLISHED
> ```
>
> Each connection is independent, tracked separately by the kernel.
>
> ## Operating System Management
>
> **Port Assignment:**
> - OS maintains a pool of available ephemeral ports
> - When application requests outbound connection, OS assigns unused port
> - Port is released when connection closes
>
> **Port Exhaustion:**
> ```
> Maximum connections from one IP to one server:port?
>
> Ephemeral port range: ~16,000 ports (49152-65535)
> Answer: ~16,000 simultaneous connections
>
> If you need more: Use multiple source IPs or connection pooling
> ```
>
> ## Real-World Examples
>
> ### Web Browsing
> ```
> Browser process manages multiple tabs:
> â€¢ Tab 1 â†’ google.com:443 (port 54321)
> â€¢ Tab 2 â†’ youtube.com:443 (port 54322)
> â€¢ Tab 3 â†’ google.com:443 (port 54323) â† Same destination!
>
> Browser correlates responses to tabs using source port
> ```
>
> ### API Requests
> ```
> Your app makes 100 API calls to api.example.com:
> â€¢ Request 1: source port 50000
> â€¢ Request 2: source port 50001
> â€¢ ...
> â€¢ Request 100: source port 50099
>
> Each response is matched to the correct callback using port number
> ```
>
> ### Database Connections
> ```
> App server with connection pool to database:
> â€¢ Connection 1: app:55001 â†’ db:3306
> â€¢ Connection 2: app:55002 â†’ db:3306
> â€¢ ...
> â€¢ Connection 10: app:55010 â†’ db:3306
>
> Pool maintains mapping of ports to query contexts
> ```
>
> ## How Response Routing Works
>
> **Outbound packet (request):**
> ```
> SRC: 192.168.1.100:54321
> DST: 172.217.14.196:443
> ```
>
> **Inbound packet (response):**
> ```
> SRC: 172.217.14.196:443
> DST: 192.168.1.100:54321  â† OS uses this to route to correct app!
> ```
>
> **OS routing logic:**
> ```
> 1. Packet arrives at network interface
> 2. OS reads destination port: 54321
> 3. Looks up socket table: port 54321 â†’ Chrome tab 1 process
> 4. Delivers data to that process's receive buffer
> 5. Chrome tab 1 reads data and renders response
> ```
>
> ## Port States
>
> View active connections:
> ```bash
> # Linux/Mac
> netstat -an | grep ESTABLISHED
> ss -tupn
> lsof -i :54321
>
> # Windows
> netstat -an | findstr ESTABLISHED
> ```
>
> ## Why This Matters
>
> **Troubleshooting:**
> - "Too many open files" error = port exhaustion
> - Connection not reused = new ephemeral port each time
> - Load balancing must consider 5-tuple, not just destination
>
> **Security:**
> - Port scanning looks for open ports
> - Firewall rules can block ephemeral port ranges
> - NAT router must track ephemeral ports for translation
>
> **Performance:**
> - Connection pooling reuses ports (more efficient)
> - HTTP/2 multiplexes requests over one connection (one port)
> - WebSockets keep connection open (port held longer)

---

## ðŸ“¡ Layer 5 - Session

### Basic Understanding
- [ ] What is the purpose of Layer 5?
- [ ] What is a session ID?
- [ ] Give 3 examples of session management
- [ ] What does "keep-alive" mean?

### Intermediate Questions
- [ ] How does a web application maintain login sessions?
- [ ] What is the difference between stateful and stateless protocols?
- [ ] Explain session timeout and why it exists
- [ ] How do video conferences maintain synchronization (Layer 5 role)?

---

## ðŸŽ¨ Layer 6 - Presentation

### Basic Understanding
- [ ] What is the purpose of Layer 6?
- [ ] Name the three main functions of Layer 6
- [ ] What is TLS/SSL and what layer does it operate at?
- [ ] Give 3 examples of data encoding/formats

### Intermediate Questions
- [ ] What is the difference between encryption at Layer 6 vs Layer 7?
- [ ] How does HTTPS use Layer 6?
- [ ] Explain character encoding (ASCII, UTF-8, Unicode)
- [ ] What is data compression and why is it useful?

---

## ðŸ‘¤ Layer 7 - Application

### Basic Understanding
- [ ] What is the purpose of Layer 7?
- [ ] Name 5 Layer 7 protocols
- [ ] What port does HTTP use? HTTPS?
- [ ] What is DNS and what port does it use?
- [ ] What is the difference between HTTP and HTTPS?

### Intermediate Questions
- [ ] Explain what happens when you type "google.com" in a browser (all layers)
- [ ] What is the difference between FTP and SFTP?
- [ ] What protocol does email use for sending? For receiving?
- [ ] Why does DNS typically use UDP instead of TCP?

### Advanced/Scenario-Based
- [ ] **Scenario:** User reports "can't access website." Walk through troubleshooting from Layer 1 to Layer 7
- [ ] **Scenario:** You're building a real-time chat app. Which transport protocol (TCP/UDP) would you choose and why?

---

## ðŸ”„ Cross-Layer Integration

### Layer Relationships
- [ ] Explain how Layers 2 and 3 work together (MAC and IP addressing)
- [ ] Explain how Layers 3 and 4 work together (IP and ports)
- [ ] How do all 7 layers work together to load a web page?

### Data Encapsulation
- [ ] What is encapsulation in networking?
- [ ] What is decapsulation?
- [ ] Draw or describe the structure of a fully encapsulated packet (all headers)
- [ ] What headers are added at each layer during transmission?

> [!question]- Trace a complete packet journey through all 7 layers
>
> ## Question
> You visit `https://bank.com` from your browser. Trace the complete journey of your request through all 7 OSI layers on both sender (your PC) and receiver (bank server) sides.
>
> ## Scenario Setup
> ```
> Your PC:       192.168.1.100 (MAC: AA:AA:AA:AA:AA:AA)
> Local Router:  192.168.1.1 (MAC: BB:BB:BB:BB:BB:BB)
> Bank Server:   172.217.14.196 (MAC: DD:DD:DD:DD:DD:DD)
> ```
>
> ## Part 1: Sending Side (Your PC) - Top to Bottom
>
> ### Layer 7 - Application
> ```
> Browser generates HTTP request:
>
> GET /account HTTP/1.1
> Host: bank.com
> User-Agent: Chrome/120.0
> Cookie: session_id=abc123
>
> Action: User clicks "View Account" button
> Output: HTTP request data ready to send
> ```
>
> ### Layer 6 - Presentation
> ```
> TLS/SSL encryption applied:
>
> â€¢ Encrypts HTTP request using AES-256
> â€¢ Compresses data with GZIP
> â€¢ Encodes as binary format
>
> Action: Secure and format the data
> Output: Encrypted, compressed HTTPS data
> ```
>
> ### Layer 5 - Session
> ```
> Session management:
>
> â€¢ Session ID: abc123 (existing login session)
> â€¢ Keep-Alive: yes (maintain connection)
> â€¢ Timeout: 30 minutes
>
> Action: Maintain session state
> Output: Session context added
> ```
>
> ### Layer 4 - Transport
> ```
> TCP header added:
>
> â€¢ Source Port: 54321 (ephemeral, random)
> â€¢ Destination Port: 443 (HTTPS)
> â€¢ Sequence Number: 1000
> â€¢ Flags: PSH, ACK
> â€¢ Checksum: calculated
>
> Action: Ensure reliable delivery, segment data
> Output: TCP segment created
> ```
>
> ### Layer 3 - Network
> ```
> IP header added:
>
> â€¢ Source IP: 192.168.1.100 (your PC)
> â€¢ Destination IP: 172.217.14.196 (bank server)
> â€¢ TTL: 64 (hop limit)
> â€¢ Protocol: TCP (6)
> â€¢ Header checksum: calculated
>
> Action: Enable end-to-end routing
> Output: IP packet created
> ```
>
> ### Layer 2 - Data Link
> ```
> Ethernet header added:
>
> â€¢ Source MAC: AA:AA:AA:AA:AA:AA (your NIC)
> â€¢ Dest MAC: BB:BB:BB:BB:BB:BB (local router - from ARP)
> â€¢ EtherType: 0x0800 (IPv4)
> â€¢ Frame Check Sequence: calculated (error detection)
>
> Action: Enable hop-to-hop delivery on local network
> Output: Ethernet frame created
> ```
>
> ### Layer 1 - Physical
> ```
> Convert to electrical signals:
>
> â€¢ Frame converted to binary: 01011010101...
> â€¢ Binary encoded as voltage levels on wire
> â€¢ Transmitted over Ethernet cable (Cat6)
>
> Action: Physical transmission
> Output: Electrical signals on wire
> ```
>
> ## Part 2: Network Path (Intermediate Hops)
>
> ### Router 1 (Local Gateway)
> ```
> Layer 1: Receives electrical signals
>          â†“
> Layer 2: Reads Ethernet frame
>          â€¢ Checks destination MAC: BB:BB:BB:BB:BB:BB (that's me!)
>          â€¢ Strips Ethernet header
>          â†“
> Layer 3: Reads IP packet
>          â€¢ Destination IP: 172.217.14.196 (not local)
>          â€¢ Checks routing table: Send to ISP gateway
>          â€¢ Decrements TTL: 64 â†’ 63
>          â†“
> Layer 2: Creates new Ethernet frame
>          â€¢ New Source MAC: Router WAN interface
>          â€¢ New Dest MAC: ISP router (from ARP)
>          â†“
> Layer 1: Transmits to ISP
> ```
>
> ### ISP Routers (Multiple Hops)
> ```
> Each router:
> 1. Receives frame (L1-L2)
> 2. Examines IP destination (L3)
> 3. Decrements TTL (63 â†’ 62 â†’ 61...)
> 4. Forwards to next hop based on routing table
> 5. New MAC addresses for each hop
> 6. IP addresses NEVER change
> ```
>
> ### Router 2 (Bank's Gateway)
> ```
> Layer 1: Receives electrical signals
>          â†“
> Layer 2: Reads Ethernet frame
>          â†“
> Layer 3: Reads IP packet
>          â€¢ Destination IP: 172.217.14.196 (that's my network!)
>          â€¢ Forwards to local server
>          â†“
> Layer 2: New Ethernet frame
>          â€¢ Dest MAC: DD:DD:DD:DD:DD:DD (server's MAC)
>          â†“
> Layer 1: Transmits on local network
> ```
>
> ## Part 3: Receiving Side (Bank Server) - Bottom to Top
>
> ### Layer 1 - Physical
> ```
> Receive electrical signals:
>
> â€¢ Electrical signals arrive on Ethernet port
> â€¢ Convert to binary: 01011010101...
> â€¢ Pass frame up to Layer 2
>
> Action: Receive physical transmission
> Output: Binary frame data
> ```
>
> ### Layer 2 - Data Link
> ```
> Read Ethernet frame:
>
> â€¢ Dest MAC: DD:DD:DD:DD:DD:DD (that's me!)
> â€¢ Source MAC: (router's MAC)
> â€¢ Verify Frame Check Sequence (no errors)
> â€¢ Strip Ethernet header
> â€¢ Pass IP packet up to Layer 3
>
> Action: Verify frame integrity, check if for this host
> Output: IP packet
> ```
>
> ### Layer 3 - Network
> ```
> Read IP packet:
>
> â€¢ Dest IP: 172.217.14.196 (that's me!)
> â€¢ Source IP: 192.168.1.100 (remember this for response)
> â€¢ Protocol: TCP (6)
> â€¢ Strip IP header
> â€¢ Pass TCP segment up to Layer 4
>
> Action: Verify this packet is for this host
> Output: TCP segment
> ```
>
> ### Layer 4 - Transport
> ```
> Read TCP segment:
>
> â€¢ Dest Port: 443 (HTTPS server process listening)
> â€¢ Source Port: 54321 (remember for response)
> â€¢ Sequence Number: 1000 (data tracking)
> â€¢ Verify checksum
> â€¢ Send ACK back to client
> â€¢ Strip TCP header
> â€¢ Pass application data up to Layer 5
>
> Action: Ensure reliable delivery, reassemble data
> Output: Application data stream
> ```
>
> ### Layer 5 - Session
> ```
> Manage session:
>
> â€¢ Recognize session ID: abc123
> â€¢ Load session context (user is logged in)
> â€¢ Maintain connection state
> â€¢ Pass data up to Layer 6
>
> Action: Identify and maintain session
> Output: Session-aware data
> ```
>
> ### Layer 6 - Presentation
> ```
> Decrypt and decode:
>
> â€¢ Decrypt TLS/SSL (AES-256)
> â€¢ Decompress GZIP
> â€¢ Decode to plain HTTP
> â€¢ Pass decrypted data up to Layer 7
>
> Action: Decrypt and format data
> Output: Plain HTTP request
> ```
>
> ### Layer 7 - Application
> ```
> Process HTTP request:
>
> GET /account HTTP/1.1
> Host: bank.com
>
> â€¢ Web server (Nginx/Apache) parses request
> â€¢ Routes to application: GET /account
> â€¢ Application checks authentication (session)
> â€¢ Queries database for account info
> â€¢ Generates HTTP response with account data
>
> Action: Execute application logic
> Output: HTTP response ready to send back
> ```
>
> ## Part 4: Response Journey (Server â†’ Client)
>
> The server now sends the response back through all 7 layers:
>
> ```
> Layer 7: Generate HTTP response (account page HTML)
>    â†“
> Layer 6: Encrypt with TLS, compress with GZIP
>    â†“
> Layer 5: Maintain session (keep-alive)
>    â†“
> Layer 4: Add TCP header (SRC port: 443, DST port: 54321)
>    â†“
> Layer 3: Add IP header (SRC IP: 172.217.14.196, DST IP: 192.168.1.100)
>    â†“
> Layer 2: Add Ethernet header (hop-by-hop MACs)
>    â†“
> Layer 1: Convert to electrical signals, transmit
> ```
>
> Client receives and processes bottom-up (L1 â†’ L7)
>
> ## Summary: What Changes vs What Stays Constant
>
> ### Constant Across Entire Journey
> ```
> âœ… Source IP: 192.168.1.100
> âœ… Destination IP: 172.217.14.196
> âœ… Source Port: 54321
> âœ… Destination Port: 443
> âœ… Application Data: HTTP request content
> âœ… Encryption: TLS-encrypted payload
> ```
>
> ### Changes at Each Hop
> ```
> âš¡ Source MAC: Changes at every device
> âš¡ Destination MAC: Changes at every device
> âš¡ TTL: Decrements at each router (64 â†’ 63 â†’ 62...)
> âš¡ Frame Check Sequence: Recalculated each hop
> ```
>
> ## Encapsulation Visualization
> ```
> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
> â”‚ Ethernet Frame (Layer 2)                            â”‚
> â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
> â”‚ â”‚ IP Packet (Layer 3)                             â”‚ â”‚
> â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
> â”‚ â”‚ â”‚ TCP Segment (Layer 4)                       â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â”‚ TLS Encrypted Data (Layer 6)            â”‚ â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â”‚ â”‚ HTTP Request (Layer 7)              â”‚ â”‚ â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â”‚ â”‚ GET /account HTTP/1.1               â”‚ â”‚ â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚
> â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚
> â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
> â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
> ```
>
> ## Time Breakdown (Approximate)
> ```
> Total time: ~50-200ms (depending on distance)
>
> â€¢ Layers 7-4 (client): <1ms (CPU processing)
> â€¢ Layers 3-1 (client): <1ms (network stack)
> â€¢ Physical transmission: 10-100ms (network latency)
> â€¢ Routers (multiple hops): 5-50ms (routing delays)
> â€¢ Layers 1-7 (server): ~2ms (processing)
> â€¢ Return journey: same time
> ```
>
> ## Why This Matters
>
> Understanding this complete flow helps with:
> - **Troubleshooting:** Identify which layer is causing issues
> - **Security:** Understand where encryption happens, where to filter
> - **Performance:** Optimize at the right layer (caching at L7, routing at L3)
> - **Design:** Choose appropriate protocols and architectures

---

## ðŸ” Security Questions

### Layer-Specific Attacks
- [ ] Name 3 Layer 1 security threats
- [ ] What is ARP spoofing/poisoning? (Layer 2)
- [ ] What is a CAM overflow attack? (Layer 2)
- [ ] What is IP spoofing? (Layer 3)
- [ ] What is a SYN flood attack? (Layer 4)
- [ ] What is a DDoS attack and at what layers can it occur?
- [ ] What is the difference between a Layer 3 and Layer 7 DDoS attack?

### Defense Mechanisms
- [ ] What layer does a firewall operate at? (Hint: multiple layers)
- [ ] What is a WAF (Web Application Firewall) and what layer does it protect?
- [ ] How does port security help prevent Layer 2 attacks?
- [ ] What is Dynamic ARP Inspection (DAI)?
- [ ] How do SYN cookies prevent SYN flood attacks?

> [!question]- Describe 3 attacks at different OSI layers
>
> ## Question
> For each layer, describe a common attack, how it works, and how to mitigate it.
>
> ---
>
> ## Layer 2 Attack: ARP Spoofing (Man-in-the-Middle)
>
> ### How It Works
> ```
> Normal ARP:
> PC A: "Who has 192.168.1.1?"
> Router: "I do! My MAC is AA:AA:AA:AA:AA:AA"
>
> ARP Spoofing:
> PC A: "Who has 192.168.1.1?"
> Attacker: "I do! My MAC is BB:BB:BB:BB:BB:BB" (FAKE!)
>
> Result: PC A caches attacker's MAC for router's IP
> All traffic intended for router goes to attacker first
> ```
>
> ### Attack Flow
> ```
> 1. Attacker sends fake ARP replies:
>    "192.168.1.1 is at BB:BB:BB:BB:BB:BB" (attacker's MAC)
>
> 2. PC A updates ARP cache:
>    192.168.1.1 â†’ BB:BB:BB:BB:BB:BB âŒ Wrong!
>
> 3. PC A sends internet traffic to attacker's MAC
>
> 4. Attacker intercepts, reads, then forwards to real router
>    â€¢ Can read/modify all traffic (Man-in-the-Middle)
>    â€¢ Can steal credentials, session cookies
>    â€¢ Can inject malicious content
> ```
>
> ### Impact
> - Intercept all network traffic from victim
> - Steal passwords, session tokens
> - Modify data in transit
> - Launch further attacks (downgrade HTTPS, phishing)
>
> ### Mitigation
> ```
> âœ… Dynamic ARP Inspection (DAI)
>    â€¢ Switch validates ARP packets against DHCP bindings
>    â€¢ Drops invalid ARP replies
>
> âœ… Static ARP Entries (critical hosts)
>    â€¢ Manually configure gateway's IPâ†’MAC mapping
>    â€¢ Cannot be overwritten by fake ARP
>
> âœ… Port Security
>    â€¢ Limit MAC addresses per switch port
>    â€¢ Prevents attacker from spoofing multiple MACs
>
> âœ… Network Monitoring
>    â€¢ Alert on ARP changes for critical hosts
>    â€¢ Detect abnormal ARP traffic patterns
>
> âœ… Encryption
>    â€¢ Use TLS/SSL (HTTPS, VPN) so intercepted traffic is encrypted
> ```
>
> ---
>
> ## Layer 3/4 Attack: SYN Flood (DDoS)
>
> ### How It Works
> ```
> Normal TCP Handshake:
> Client â†’ Server: SYN
> Server â†’ Client: SYN-ACK
> Client â†’ Server: ACK
> Connection established
>
> SYN Flood Attack:
> Attacker â†’ Server: SYN (fake source IP)
> Server â†’ Fake IP: SYN-ACK (goes to wrong place)
> [No ACK ever comes]
> Server: Waits... connection left half-open
>
> Attacker sends THOUSANDS per second with different fake IPs
> ```
>
> ### Attack Flow
> ```
> 1. Attacker spoofs source IP addresses:
>    SYN from 1.2.3.4
>    SYN from 5.6.7.8
>    SYN from 9.10.11.12
>    ... (thousands per second)
>
> 2. Server sends SYN-ACK to each fake IP:
>    SYN-ACK â†’ 1.2.3.4 (real host, didn't send SYN, confused)
>    SYN-ACK â†’ 5.6.7.8 (maybe offline)
>    SYN-ACK â†’ 9.10.11.12 (receives unexpected packet, ignores)
>
> 3. Server waits for ACK that never comes:
>    â€¢ Each half-open connection consumes memory
>    â€¢ Fills server's connection backlog queue
>    â€¢ After ~60 seconds, timeout and close
>
> 4. New legitimate clients cannot connect:
>    â€¢ "Connection refused" or timeout
>    â€¢ Service unavailable (DoS achieved)
> ```
>
> ### Impact
> - Server resources exhausted (memory, CPU)
> - Connection table full, cannot accept new connections
> - Legitimate users cannot access service
> - Can take down web servers, email servers, etc.
>
> ### Mitigation
> ```
> âœ… SYN Cookies
>    â€¢ Don't allocate resources until final ACK received
>    â€¢ Encode connection state in sequence number
>    â€¢ Modern Linux/BSD have this enabled by default
>
> âœ… Rate Limiting
>    â€¢ Limit SYN packets per source IP
>    â€¢ Drop excess SYN packets
>    â€¢ Firewall rules: iptables/nftables rate limit
>
> âœ… Increase Backlog Queue
>    â€¢ Allow more half-open connections
>    â€¢ Buy time for SYN cookies to activate
>    â€¢ sysctl: net.ipv4.tcp_max_syn_backlog
>
> âœ… Reverse Proxy / CDN
>    â€¢ Cloudflare, AWS Shield, Akamai
>    â€¢ Absorb attack before reaching origin server
>    â€¢ Challenge suspicious sources
>
> âœ… Traffic Analysis
>    â€¢ Detect abnormal SYN:ACK ratios
>    â€¢ Block source IPs/networks sending floods
>    â€¢ BGP blackhole routing for severe attacks
> ```
>
> ---
>
> ## Layer 7 Attack: HTTP Flood (Application DDoS)
>
> ### How It Works
> ```
> Attacker sends legitimate-looking HTTP requests that are
> expensive for the server to process.
>
> Normal request:
> GET / HTTP/1.1
> Host: example.com
>
> Attack requests:
> POST /search?q=expensive_query HTTP/1.1
> POST /api/report?start_date=2000-01-01&end_date=2025-12-31
> GET /slow_endpoint HTTP/1.1 (requires database query)
>
> Thousands of requests per second to expensive endpoints
> ```
>
> ### Attack Flow
> ```
> 1. Attacker establishes many legitimate TCP connections:
>    â€¢ Complete 3-way handshake (looks normal)
>    â€¢ Can come from multiple IPs (botnet)
>
> 2. Sends HTTP requests to resource-intensive endpoints:
>    â€¢ Search queries with complex regex
>    â€¢ Reports that scan entire database
>    â€¢ File uploads that fill disk
>    â€¢ API calls that trigger expensive calculations
>
> 3. Server processes each request:
>    â€¢ CPU usage spikes (complex queries)
>    â€¢ Database overwhelmed (slow queries)
>    â€¢ Memory fills up (caching, processing)
>    â€¢ Disk I/O saturated (logs, uploads)
>
> 4. Legitimate users experience:
>    â€¢ Slow response times (seconds to minutes)
>    â€¢ Timeouts (503 Service Unavailable)
>    â€¢ Application crashes
> ```
>
> ### Why Layer 7 Attacks Are Hard to Stop
> - Look like legitimate traffic (valid HTTP)
> - Complete TCP handshakes (not SYN flood)
> - May come from many IPs (botnet)
> - Difficult to distinguish from real users
> - Abuse application logic (not network layer)
>
> ### Impact
> - Application becomes unresponsive
> - Database overload (slow queries)
> - Server resources exhausted (CPU, memory, disk)
> - Costs increase (cloud auto-scaling, bandwidth)
> - Revenue loss (e-commerce downtime)
>
> ### Mitigation
> ```
> âœ… Web Application Firewall (WAF)
>    â€¢ Cloudflare, AWS WAF, ModSecurity
>    â€¢ Rate limiting per IP/user
>    â€¢ Challenge suspicious requests (CAPTCHA)
>    â€¢ Block known bad bots (user-agent, behavior)
>
> âœ… Rate Limiting (Application Level)
>    â€¢ Limit requests per IP: 100/minute
>    â€¢ Limit expensive operations: 10/hour per user
>    â€¢ Return 429 Too Many Requests
>
> âœ… Caching
>    â€¢ Cache expensive query results (Redis, Memcached)
>    â€¢ CDN for static assets
>    â€¢ Reduce database load
>
> âœ… Query Optimization
>    â€¢ Add database indexes for common queries
>    â€¢ Set query timeouts (kill slow queries)
>    â€¢ Limit result set size
>
> âœ… Authentication & Authorization
>    â€¢ Require login for expensive operations
>    â€¢ Higher rate limits for authenticated users
>    â€¢ Block guest/anonymous abuse
>
> âœ… Traffic Analysis & Anomaly Detection
>    â€¢ Monitor request patterns
>    â€¢ Detect unusual spikes in traffic
>    â€¢ Automatic blocking of suspicious IPs
>
> âœ… Load Balancing & Auto-scaling
>    â€¢ Distribute load across multiple servers
>    â€¢ Auto-scale to handle legitimate spikes
>    â€¢ Graceful degradation (queue, backpressure)
> ```
>
> ---
>
> ## Comparison Summary
>
> | Aspect | L2 ARP Spoofing | L3/4 SYN Flood | L7 HTTP Flood |
> |--------|-----------------|----------------|---------------|
> | **Target** | Local network | Network/Transport | Application |
> | **Goal** | Intercept traffic | Exhaust connections | Exhaust resources |
> | **Detectability** | Medium | Easy | Hard |
> | **Mitigation** | DAI, port security | SYN cookies, rate limit | WAF, rate limit, caching |
> | **Scope** | Local network | Network-wide | Application-specific |
> | **Defense Layer** | Switch | Firewall/Router | WAF/Application |
>
> ## Key Insight
>
> Attacks at different layers require different defense strategies:
> - **Lower layers (1-4):** Network devices (switches, firewalls) can help
> - **Upper layers (5-7):** Application-level defenses needed (WAF, code fixes)
> - **Defense in depth:** Use protections at multiple layers

---

## ðŸŽ“ OSI vs TCP/IP Model

### Understanding the Models
- [ ] How many layers in the TCP/IP model?
- [ ] Which OSI layers are combined in TCP/IP's Application layer?
- [ ] Why learn OSI if TCP/IP is more practical?
- [ ] What is the "Internet layer" in TCP/IP equivalent to in OSI?

### Comparison
- [ ] Compare OSI and TCP/IP models (at least 3 differences)
- [ ] Map OSI layers to TCP/IP layers
- [ ] Why does TCP/IP combine layers 5-7?

---

## ðŸŽ¯ Practical Application

### Troubleshooting Scenarios

> [!question]- Network troubleshooting: Bottom-up approach
>
> **Scenario:** User reports "Website won't load." Walk through systematic troubleshooting using the OSI model.
>
> ## Layer 1 - Physical
> ```
> âœ… Check:
> â€¢ Is cable plugged in? (both ends)
> â€¢ Are link lights on NIC/switch port?
> â€¢ Try different cable?
> â€¢ Try different port?
>
> Test: ping 127.0.0.1 (loopback - tests network stack)
>
> If Layer 1 fails: Replace cable, check port, check NIC driver
> ```
>
> ## Layer 2 - Data Link
> ```
> âœ… Check:
> â€¢ Is NIC enabled? (ip link show / ifconfig)
> â€¢ MAC address present?
> â€¢ Can reach other devices on local network?
> â€¢ Switch port configured correctly (VLAN, port security)?
>
> Test: arp -a (see if gateway MAC is cached)
>       ping gateway (192.168.1.1)
>
> If Layer 2 fails: Check switch config, VLAN membership, port security
> ```
>
> ## Layer 3 - Network
> ```
> âœ… Check:
> â€¢ IP address assigned? (ip addr / ipconfig)
> â€¢ Correct subnet?
> â€¢ Default gateway configured?
> â€¢ Can ping gateway?
> â€¢ Can ping external IP (8.8.8.8)?
>
> Test: ping 8.8.8.8 (Google DNS)
>       traceroute 8.8.8.8 (see routing path)
>
> If Layer 3 fails: Check IP config, routing table, gateway reachability
> ```
>
> ## Layer 4 - Transport
> ```
> âœ… Check:
> â€¢ Can establish TCP connection?
> â€¢ Firewall blocking port?
> â€¢ Is service listening on expected port?
>
> Test: telnet website.com 80
>       nc -zv website.com 443
>       netstat -an | grep :443
>
> If Layer 4 fails: Check firewall rules, port forwarding, service status
> ```
>
> ## Layer 7 - Application
> ```
> âœ… Check:
> â€¢ DNS resolving correctly?
> â€¢ HTTP status code (404, 500, 502)?
> â€¢ Application logs show errors?
> â€¢ TLS certificate valid?
>
> Test: nslookup website.com
>       curl -I https://website.com
>       dig website.com
>
> If Layer 7 fails: Check DNS, application logs, server status, proxy config
> ```
>
> ## Decision Tree
> ```
> Website won't load
>    â†“
> Ping 127.0.0.1
>    â”œâ”€ Fail â†’ Layer 1/2 (network stack issue)
>    â””â”€ Success â†’ Continue
>          â†“
> Ping gateway (192.168.1.1)
>    â”œâ”€ Fail â†’ Layer 2/3 (local network issue)
>    â””â”€ Success â†’ Continue
>          â†“
> Ping 8.8.8.8
>    â”œâ”€ Fail â†’ Layer 3 (routing/gateway issue)
>    â””â”€ Success â†’ Continue
>          â†“
> nslookup website.com
>    â”œâ”€ Fail â†’ DNS issue (Layer 7)
>    â””â”€ Success â†’ Continue
>          â†“
> curl https://website.com
>    â”œâ”€ Timeout â†’ Layer 4 (firewall/port)
>    â”œâ”€ 404/500 â†’ Layer 7 (application error)
>    â””â”€ Success â†’ Issue is client-side (browser cache, etc.)
> ```

### Design Questions
- [ ] **Design:** Network for 100 employees across 3 departments that shouldn't see each other's traffic. What devices/layers?
- [ ] **Design:** Real-time video streaming service. Which protocols at each layer would you use?
- [ ] **Design:** Secure remote access solution for employees. Map security controls to OSI layers.

### Analysis Questions
- [ ] Use Wireshark to capture a packet. Identify headers from each layer.
- [ ] Run `traceroute`/`tracert` to a website. How many Layer 3 hops?
- [ ] View `netstat` or `ss` output. Identify Layer 4 information (ports, protocols, states).

---

## âœ… Completion Tracking

> [!tip] Study Tips
> - **Don't just memorize** - understand the "why" behind each layer
> - **Draw diagrams** - visualize data flow through layers
> - **Use labs/simulators** - Practice with Packet Tracer, GNS3, or real networks
> - **Teach concepts** - Explain to someone else to verify understanding
> - **Real-world correlation** - Map every network issue to an OSI layer
> - **Security mindset** - For each layer, think "how could this be attacked?"

### Progress Tracker

**Layer 1 - Physical**: ___/12 questions completed
**Layer 2 - Data Link**: ___/25 questions completed
**Layer 3 - Network**: ___/22 questions completed
**Layer 4 - Transport**: ___/20 questions completed
**Layer 5 - Session**: ___/4 questions completed
**Layer 6 - Presentation**: ___/8 questions completed
**Layer 7 - Application**: ___/12 questions completed
**Cross-Layer Integration**: ___/8 questions completed
**Security**: ___/15 questions completed
**OSI vs TCP/IP**: ___/6 questions completed
**Practical Application**: ___/9 questions completed

---

**Total Questions**: 141
**Completed**: ___ / 141
**Last reviewed**: _______________

---

## ðŸ“… Spaced Repetition Schedule

Use this schedule to maximize retention:

- **First review**: 1 day after completing notes
- **Second review**: 3 days later
- **Third review**: 1 week later
- **Fourth review**: 2 weeks later
- **Fifth review**: 1 month later

### Review Checklist

- [ ] Day 1: Complete initial question review (focus on recall questions)
- [ ] Day 4: Review flagged questions + scenario questions
- [ ] Day 11: Full review of all layers
- [ ] Day 25: Advanced scenarios + security questions
- [ ] Day 55: Comprehensive review + practical troubleshooting

---

## ðŸ”— Related Notes

- [[2. OSI Model]] - Main notes
- [[1. Network Devices - Hubs, Bridges, Switches, and Routers]]
- [[OSI-Model-Interactive.html]] - Interactive visualization

---

_Created: 2025-10-11_
_Based on: 2. OSI Model.md_
_Purpose: Spaced repetition and active recall for deep understanding_